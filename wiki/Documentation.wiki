*NOTE: clUtil is undergoing major revisions and parts of this documentation may now be inaccurate*

<wiki:toc max_depth="3" />

=Introduction=

If any of you have used OpenCL, you'll know that running a program in OpenCL is anything but easy. Consider the following example that fills an array with a specified value.
main.cc:
{{{
#include <Opencl/cl.h>

char const* kernelSource = "__kernel void fill(__global float* array, unsigned int arrayLength, float val)"
"{"
"    if(get_global_id(0) < arrayLength)"
"    {"
"        array[get_global_id(0)] = val;}"
"    }"
"}";

int main(int argc, char** argv)
{
    float val = 20.0f;
    float array[2000]
    cl_int err;
    cl_platform_id platform;
    cl_device_id device;
    cl_context context;
    cl_command_queue commandQueue;
    cl_mem buffer;
    cl_program program;
    cl_kernel kernel;
    unsigned int length = 2000;

    //Initialization
    err = clGetPlatform_IDs(1, &platform, NULL);
    err = clGetDeviceIDs(platform, CL_DEVICE_TYPE_ANY, 1, &device, NULL);
    context = clCreateContext(NULL, 1, &device, NULL, NULL, &err);
    commandQueue = clCreateCommandQueue(context, device, 0, &err);
    program = clCreateProgramWithSource(context, 1, &kernelSource, 0, &err);
    err = clBuildProgram(program, 1, &device, NULL, NULL, NULL);
    kernel = clCreateKernel(program, "fill", &err);

    //Allocate memory    
    buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, sizeof(array), NULL, &err);

    //Actually call the kernel
    err = clSetKernelArg(kernel, 0, sizeof(buffer), &buffer);
    err = clSetKernelArg(kernel, 1, sizeof(length), &length);
    err = clSetKernelArg(kernel, 2, sizeof(val), &val);

    size_t global;
    size_t local = 64;
    
    global = length % local == 0 ? length : (length / local + 1) * local;

    err = clEnqueueNDRangeKernel(commandQueue, kernel, 1, NULL, &global, &local, 0, NULL, NULL);

    //Copy data back
    err = clEnqueueReadBuffer(commandQueue, buffer, CL_TRUE, 0, sizeof(array), array, 0, NULL, NULL);

    //Free the data on the GPU
    clReleaseMemObject(buffer);
}
}}}

This program doesn't even do error checking, which would at least double the program's length! clUtil dramatically improves frontend expressivity without significantly hurting flexibility. This means you write less code, spend less time debugging, and more time getting results.

The equivalent program in clUtil is as follows:

kernel.cl:
{{{
__kernel void fill(__global float* array, unsigned int arrayLength, float val)
{
    if(get_global_id(0) < arrayLength)
    {
        array[get_global_id(0)] = val;
    }
}
}}}
main.cc:
{{{
#include <clUtil.h>

int main(int argc, char** argv)
{
    const char* kernelFiles[] = {"kernel.cl"};
    const unsigned int kLength = 2000;
    float array[kLength];
    float val = 20.0f;

    Device::InitializeDevices(kernelFiles, 1);
    Buffer buffer(sizeof(array));

    clUtilEnqueueKernel("fill", clUtilGrid(length, 64), buffer, length, val);
    clUtilDeviceGet(array, sizeof(array), buffer);

    return 0;
}
}}}

=Design=

Simplifying the OpenCL API requires several assumptions and design decisions that trade expressivity for flexibility. This being said, clUtil still provides enough options for most applications. These assumptions include:
Simplified device/platform model
Simpler memory model
Stronger programming model
clUtil uses many features not available in C such as parameter defaulting and STL objects. Additionally, it uses variadic templates for launching kernels. Because of these language features, clUtil requires a C++ compiler with at least variadic template support of the C++0x standard. As such, one of the following compilers is required:
  * g++ 4.3 or later (use -std=c++0x flag on any file that includes clUtil.h). We have tested g++ 4.4.1, 4.5.2, and 4.6 with x86_64-linux-gnu target.
We currently support Linux running OpenCL 1.1 or later. At present, we have tested clUtil using ATI's StreamSDK, Nvidia's CUDA, and Intel's OpenCL SDK (though, I can't remember the nonsense you have to do with libnuma to avoid a segfault).

==Device Model==

clUtil makes no distinction between device platforms. Devices are devices and will implicitly run on the correct platform. On initialization, clUtil queries every platform available and combines all their device listings into a unified device list with the following assumptions (which will likely be loosened in the future):
  * Each device has a single context.
  * Each device has a two command queues, switched at programmer discretion. Both queues execute operations in order, but only because not every SDK supports OOO execution. 

clUtil has a simple C++ RAII friendly memory model. Users allocate buffers by creating buffer objects. Image objects embody 1, 2, and 3-D images. When calling their copy constructor, clUtil calls clRetainMemObject. When they destruct, clUtil calls clReleaseMemObject. 

clUtil's memory model provides fewer options than vanilla OpenCL. All buffers are allocated on the currently selected device's only context. All buffers are read/write. Host pointer capabilities exist through passing additional parameters to a buffer's constructor.

clUtil adds convenience functions for representing matrices as 2D images. Furthermore, clUtil adds support for 1D images by emulating them using 2D images. Additional functions exist in clUtil to create, copy to, and copy from 1-D images. They are visible to kernels as image1d_t types and are read and written to using [http://code.google.com/p/clutil/wiki/Documentation#1D_Image_Routines language extensions].

==Programming model==

clUtil makes dramatically simplifies OpenCL's programming model. Developers no longer have to worry about kernels, programs, binaries, etc. clUtil takes a list of source code files at initialization and compiles them all for each device on the machine. Calling a kernel is as simple as calling clUtil_enqueueKernel() after initialization with the kernel name, work dimension, global work size, local work size, and the arguments to the kernel. 

Since compiling source code can be take a while, developers can optionally pass a list of binary names to the initialization routine, causing clUtil to load kernels from these files if they exist. If they don't exist, clUtil will compile from source and save these binary files. This means that many applications can cache their programs after the first time the application is run.

===Synchronicity===

All clUtil data transfer and kernel enqueue functions execute asynchronously. The runtime manages cl_event objects on behalf of the user to ensure correct execution order regardless of which queue a task executes from. These events also can optionally provide profiling information.

==Thread safety==

clUtil is not currently thread safe. We have no plans to make it so, as our model consists of a sequential master thread issuing tasks to devices. If absolutely need thread safety, you can put mutex locks around regions that assume a specific current device. For example:

{{{
mutex_lock(...);

Device::SetCurrentDevice(...);

buffer.put(...);
clUtilEnqueueKernel(...);
buffer.get(...);

mutex_unlock(...);
}}}

Since all transfer and kernel functions execute asynchronously, the amount of time spent in the critical section should be minimal.

=User Guide=

A typical OpenCL, CUDA, or clUtil application has a motif similar to the following:
  # Initialize
  # Allocate memory
  # Copy data to device
  # Run kernels
  # Copy data from device
  # Repeat 3-5
  # Shutdown

==Initialization/Device Managment==

Users populate the list of available devices by calling `Device::FetchDevices()`. This populates the device list and fetches device info for each device. Users can then get the list of devices and examine their information (and that's about it). This function allows for pre-initialization computation to discover which devices the program should use for what, how to use them, and some other advanced topics.

To get a STL vector of the available device, call `Device::GetDevices()`. This vector is immutable.

To set the current device, call `Device::SetCurrentDevice(size_t num)`

To query the current device, call `Device::GetCurrentDevice()`

To get the cardinal number of the current device, call `Device::GetCurrentDeviceNum()`.

Calling the `getDeviceInfo()` member function returns a structure containing all the queryable features obtainable through `clGetDeviceInfo()`.

The features available by this pre-initialization step are very limited. To perform full initialization, the user calls `Device::InitializeDevices()`. Calling this function will implicitly call `Device::FetchDevices()` is not already called. This function accepts a list of OpenCL source code files, and optionally an object file cache name and additional compiler options.

`Device::InitializeDevices()` creates contexts on each device, creates two command queues, compiles the source objects into a program, and fetches kernel objects from said program, storing them in a data structure. After calling this function, users are ready to allocate buffers on devices and enqueue kernels and data transfers.

==Memory Management==

Buffer and Image objects back buffers and images residing on the GPU. By virtue of instantiating one of these objects, the clUtil runtime calls `clCreateBuffer()` or `clCreate{2|3}DImage()`. Both of these objects inherit from the abstract Memory class, which contains the underlying memory handle and access event. The Memory class also manages reference counting via its copy constructors (which call `clRetainMemObject()`) and destructors (which call `clReleaseMemObject()`).

Memory objects are exception safe; if an exception is thrown, all buffer objects presently in scope will do the right thing according to OpenCL's reference counting mechanism (which may or may not release the underlying memory if there exist valid copies of the object). This highlights the importance of using `shared_ptr<>` and `unique_ptr<>` (both reside in STL as of C++11) data types, as these pointers add exception safety for dynamically allocated objects. 

To transfer data between device and host, call the `get()` member function.

To transfer data between host and device, call the `put()` member function.

==Error handling==

clUtil manages errors through exceptions. If something anomalous occurs, in a clUtil library function, the runtime throws a `clUtilException`. Inheriting from `std::exception`, users can use the `what()` member function to get a human readable string description of the error that occurred. In the future, we plan to be better people, and create an exception class for every exception type, allowing for more interesting try/catch blocks. However, for the time being, using a catchall for clUtilException or even std::exception provides sufficient notification for debugging.

For those of you not aware, in gdb you can call "catch throw" and gdb will break whenever any exception is thrown. This is useful for getting stack traces and finding the exact point in time an error occurs, as well as why it occurred.

==Kernels==

To launch a kernel, call clUtilEnqueueKernel() with the name of the kernel, the work dimension, global size, local size, and arguments to the kernel. This function looks up the kernel by name in a hash table for the current device that is created when clUtil is initialized.

==Images==

clUtil's image functions are designed to be used with matrix data for linear algebra routines. They are intended to temporarily hold copies of matrices in images so they can run through the texture cache as inputs to a kernel. 

==Platform/Device Specific Compilation==

Presently, no implementation of OpenCL is perfect and each has various bugs and/or non-standard implementation details that need to have #define workarounds. Absent this, users may wish to include device-specific optimizations, such as using float4s on ATI hardware or unrolling loops to different lengths based on the underlying architecture. To facilitate this, clUtil defines macros for the current device vendor and (coming soon!) the current platform vendor. The macro defined is an uppercase version of the string returned by clGetDeviceInfo() with CL_DEVICE_VENDOR with spaces, commas, and periods replaced with underscores. 
NVIDIA CUDA SDK

  * Passing __constant address space pointers to kernels often causes compilation issues or doesn't work. Use __global instead.
AMD Stream SDK 2.3

  * Double precision is enabled via #pragma cl_amd_fp64 : enable instead of cl_khr_fp64 : enable.
  * Samplers can be inline declared in OpenCL programs using const sampler_t mySampler = CLK_NORMALIZED_COORDS_TRUE or __constant sampler_t mySampler = CLK_NORMALIZED_COORDS_TRUE. The former is non-standard and the only way to do it in v2.2. The latter is the standard way and is only supported in v2.3 and later.
  * As of v2.3, 1D images don't work (tested on Intel X5570) because 2D images don't work.

----

=Reference=

==Initialization==

===clUtilInitialize()===
{{{
cl_int clUtilInitialize(char** fileNames, 
                        size_t numFiles, 
                        const char* cacheName = NULL, 
                        const char* options = NULL)
}}}

This function initializes the clUtil runtime and must be the first clUtil function called. It initializes all devices on all platforms, creates a single context and command queue on each device, compiles all files given in fileNames into a single program on each device (or if possible load them from cached binaries), and set the current device to 0.

Parameters:
  # fileNames: an array of C-strings including filenames to be compiled into program on each device. Can have either relative or full paths to files.
  # numFiles: the number of files to be compiled
  # cacheName (optional): The name of the precompiled binary to be loaded as a program. Each device will have a file named (cacheName).device(deviceNumber). If the binaries don't exist, then they are compiled and saved to disk for future use.
  # options (optional): options passed to OpenCL compiler
Return:
    CL_SUCCESS if no error occurred. Otherwise, an error code corresponding to the erroneous underlying OpenCL call is returned after performing the previously described error handling.

===clUtilFinalize()===
{{{
cl_int clUtilFinalize()
}}}

Frees memory used by clUtil and is typically the last thing called by an application. After clUtilFinalize() is called, any subsequent clUtil API calls result in undefined behavior. 

Parameters:
    None
Return:
    clUtilFinalize() should never return anything other than CL_SUCCESS if called after a successful clUtilInitialize(). If it does, please file a bug report.

===clUtilEnableOOOExecution()===
{{{
void clUtilEnableOOOExecution()
}}}

When called before clUtilInitialize(), enables out of order execution on any devices that support it. This function does nothing if called after clUtilInitialize(). If a given device does not support this feature, it will execute commands in order. See section 5.11 of the OpenCL spec for more information on this feature.

Parameters:
    None
Return:
    None

==Memory Management==

===clUtilAlloc()===

{{{
clUtilAlloc(size_t bytes, cl_mem* gpuBuffer)
}}}

Allocates memory on the currently selected device.

Parameters:
  # bytes: number of bytes to be allocated
  # gpuBuffer: points to a cl_mem handle that is assigned if memory is successfully allocated.

Return:
    CL_SUCCESS if no error occurred. Otherwise, an error code corresponding to the erroneous underlying OpenCL call is returned after performing the previously described error handling.

===clUtilFree()===
{{{
clUtilFree(cl_mem buffer)
}}}
Frees a buffer after all previously enqueued kernels referencing it finish.

Parameters:

  # buffer: a cl_mem handle to the buffer to be freed

Return:
    CL_SUCCESS if no error occurred. Otherwise, an error code corresponding to the erroneous underlying OpenCL call is returned after performing the previously described error handling.

===clUtilDevicePut() (synchornous)===
{{{
cl_int clUtilDevicePut(void* buffer, size_t len, cl_mem gpuBuffer)
}}}
Copies data from the host buffer "buffer" to the device buffer "gpuBuffer" and returns when the copy is complete. Note: gpuBuffer must reside on the currently selected device or an error will occur. This function blocks until the copy completes.

Parameters:

  # buffer: a pointer to the zeroth element on the host's buffer
  # len: number of bytes of data to be copied
  # gpuBuffer: a cl_mem handle to the device buffer.
Return:
    CL_SUCCESS if no error occurred. Otherwise, an error code corresponding to the erroneous underlying OpenCL call is returned after performing the previously described error handling.

===clUtilDeviceGet() (synchronous)===
{{{
cl_int clUtilDeviceGet(void* buffer, size_t len, cl_mem gpuBuffer)
}}}
Copies data from the device buffer "gpuBuffer" to the host buffer "buffer" and returns when the copy is complete. Note: gpuBuffer must reside on the currently selected device or an error will occur. This function blocks until the copy completes.

Parameters:

  # buffer: a pointer to the zeroth element on the host's buffer
  # len: number of bytes of data to be copied
  # gpuBuffer: a cl_mem handle to the device buffer.
Return:
    CL_SUCCESS if no error occurred. Otherwise, an error code corresponding to the erroneous underlying OpenCL call is returned after performing the previously described error handling.

===clUtilDevicePut() (asynchornous)===
{{{
cl_int clUtilDevicePut(void* buffer, size_t len, cl_mem gpuBuffer, clUtilCallback&& callback, bool shouldFlush = true)
}}}
Asynchronously copies data from the host buffer "buffer" to the device buffer "gpuBuffer." Note: gpuBuffer must reside on the currently selected device or an error will occur. This function returns immediately.
When the copy complete's, the runtime calls "callback." Callbacks must be thread safe, as they are generally not called by the main thread.
If flush is true (the default), clFlush() is called on the current device's queue so the copy (and anything else in the queue) begin executing on the device. If flush is false, then clFlush() is not called and the copy may remain queued until the next flush is called. This permits optimization, as developers can have only the last concurrent asynchronous action issue the flush. This function should not block regardless of the value of flush, since clFlush() does not block (e.g. it is not clFinish).

Parameters:

  # buffer: a pointer to the zeroth element on the host's buffer
  # len: number of bytes of data to be copied
  # gpuBuffer: a cl_mem handle to the device buffer.
  # callback: the function called when the copy completes. Must have the interface void callback(void). Must be thread safe.
  # shouldFlush: if true, clUtilDevicePut() calls clFlush() after issuing the copy to the current devices command queue. If false, it only issues the copy into the command queue; it doesn't call clFlush(). This parameter defaults to true.

Return:
    CL_SUCCESS if no error occurred. Otherwise, an error code corresponding to the erroneous underlying OpenCL call is returned after performing the previously described error handling.

===clUtilDeviceGet() (asynchronous)===
{{{
cl_int clUtilDeviceGet(void* buffer, size_t len, cl_mem gpuBuffer, clUtilCallback&& callback, bool shouldFlush = true)
}}}
Asynchronously copies data from the device buffer "gpuBuffer" to the host buffer "buffer." Note: gpuBuffer must reside on the currently selected device or an error will occur. This function returns immediately.
When the copy complete's, the runtime calls "callback." Callbacks must be thread safe, as they are generally not called by the main thread.
If flush is true (the default), clFlush() is called on the current device's queue so the copy (and anything else in the queue) begin executing on the device. If flush is false, then clFlush() is not called and the copy may remain queued until the next flush is called. This permits optimization, as developers can have only the last concurrent asynchronous action issue the flush. This function should not block regardless of the value of flush, since clFlush() does not block (e.g. it is not clFinish).

Parameters:

  # buffer: a pointer to the zeroth element on the host's buffer
  # len: number of bytes of data to be copied
  # gpuBuffer: a cl_mem handle to the device buffer.
  # callback: the function called when the copy completes. Must have the interface void callback(void). Must be thread safe.
  # shouldFlush: if true, clUtilDevicePut() calls clFlush() after issuing the copy to the current devices command queue. If false, it only issues the copy into the command queue; it doesn't call clFlush(). This parameter defaults to true.

Return:
    CL_SUCCESS if no error occurred. Otherwise, an error code corresponding to the erroneous underlying OpenCL call is returned after performing the previously described error handling.

==Device Management==
===clUtilSetDeviceNum()===
{{{
cl_int clUtilSetDeviceNum(cl_int device)
}}}
Sets the current device to "device."

Parameters:

  # device: the cardinal number of the device to use. Devices can reside on any of the underlying platforms. Note that it's possible for the same device to appear several times if it's supported by multiple platforms. 
Return:
    CL_SUCCESS if no error occurred. CL_INVALID_VALUE if device is larger than the number returned by getNumDevices() or is negative.

===clUtilGetDeviceNum()===
{{{
cl_int clUtilGetDeviceNum()
}}}
Returns the cardinal number of the currently selected device or -1 if clUtilInitialize() has not been called.

Parameters:
    None
Return:
    The cardinal number of the currently selected device.

===clUtilGetNumDevices()===
{{{
cl_uint clUtilGetNumDevices()
}}}
Returns the sum of all devices on all platforms or 0 if either clUtilInitialize() has not been called or no device is supported by any OpenCL platform. Some devices may be enumerated more than once if they are supported by more than one platform.

Parameters:
    None
Return:
    The total number of devices on the system.

===clUtilGetDeviceName()===
{{{
char* clUtilGetDeviceName()
}}}
Returns a C-string containing the current device's name (e.g. GTX 480, Radeon 5870, etc.).

Parameters:
    None
Return:
    A C-string containing the currently selected device's name.

===clUtilGetDeviceVendor()===
{{{
char* clUtilGetDeviceVendor()
}}}
Returns a C-string containing the current device's vendor (e.g. Intel, Advance Micro Devices Inc., etc.).

Parameters:
    None
Return:
    A C-string containing the currently selected device's vendor.

===clUtilGetDeviceDriver()===
{{{
char* clUtilGetDeviceDriver()
}}}
Returns a C-string containing the current device's driver version number.

Parameters:
    None
Return:
    A C-string containing the currently selected device's driver version.

===clUtilGetMaxWriteImages()===
{{{
cl_uint clUtilGetMaxWriteImages()
}}}
Returns the maximum number of images any kernel can write to.

Parameters:
    None
Return:
    An unsigned integer containing the number of images a kernel running on the current device can write to.

===clUtilGetSupportedImageFormats()===
{{{
void clUtilGetSupportedImageFormats()
}}}
Prints all image formats supported by the currently selected device to stdout.

Parameters:
    None
Return:
    None

==Accessing internals==
===clUtilGetCommandQueue()===
{{{
cl_command_queue clUtilGetCommandQueue()
}}}
Returns the command queue associated with the current device or zero if the current device is invalid.

Parameters:
    None

Return:
    The command queue associated with the current device.

===clUtilGetContext()===
{{{
cl_context clUtilGetContext()
}}}
Returns the context associated with the current device or zero if the current device is invalid.

Parameters:
    None

Return:
    The context associated with the current device.

===clUtilGetDevice()===
{{{
cl_device_id clUtilGetDevice()
}}}
Returns the cl_device_id associated with the current device number or zero if the current device is invalid.

Parameters:
    None

Return:
    The device associated with the current device number or zero if it's invalid.


==Error handling==

===clUtilCheckErrorVoid(err)===
{{{
clUtilCheckErrorVoid(err) //[MACRO]
}}}
If err equals CL_SUCCESS, does nothing. Otherwise, it prints the file and line number of the call site as well as the plain text string of err. It then raises a trap signal and causes the calling function to immediately void return.

Parameters:
  # err: a cl_int representing an error code from an OpenCL or clUtil function call.
Return:
    Causes calling function to void return.

===clUtilCheckError(err, returnVal)===
{{{
clUtilCheckError(err, returnVal) //[MACRO]
}}}
If err equals CL_SUCCESS, does nothing. Otherwise, it prints the file and line number of the call site as well as the plain text string of err. It then raises a trap signal and causes the calling function to immediately return returnVal.

Parameters:
  # err: a cl_int representing an error code from an OpenCL or clUtil function call.
  # returnVal: the value the calling function should return.
Return:
    Causes the calling function to return returnVal.

===clUtilGetErrorCode()===
{{{
const char* clUtilGetErrorCode(cl_int err)
}}}
Returns a C-string containing the English text description of OpenCL error code err.

Parameters:
  # err: a cl_int representing an error code from an OpenCL or clUtil function call.
Return:
    A C-string containing a description of err.

==Kernels==
===clUtilGrid()===
{{{
clUtil::_Grid<> clUtilGrid(globalDim1, localDim1, globalDim2, localDim2, ...)
}}}
A variadic factory function that generates work information for clUtilEnqueueKernel(). Due to implementation details, this function should be used inline as a parameter to clUtilEnqueueKernel or assigned to an rvalue reference (e.g. clUtil::Grid&& gridRef = clUtilGrid(global1, local1, ...). This function rounds each global work size to the next largest multiple of the corresponding local size (unless the global work size is already a multiple of the local). Global and local work items must always come in pairs; failing to do so will result in a template instantiation error.

Parameters:
  # globalDim1: The total number of work items in the first dimension. See OpenCL spec on work items.
  # localDim1: The number of works items per work group in the first dimension.
  # ...

Return:
    A nasty subclassed templated thingy that should only be passed to clUtilEnqueueKernel.

===clUtilEnqueueKernel() (no callback notification)===
{{{
void clUtilEnqueueKernel(const char* kernelName,
                         clUtilGrid(globalDim1, localDim1, globalDim2, localDim2, ...)
                         Args... args)
}}}
Enqueues a kernel with function name kernelName on the current device and immediately returns. This function is variadic, so an arbitrary number of arguments can be specified as parameters to the kernel. This function does not call clFlush(), so the kernel may not actually start executing until the user calls clFlush(), clFinish(), a blocking copy, or an asychronous copy with shouldFlush equal to true. There is no way to know when the kernel finished except with an immediate subsequent clFinish() call.

Parameters:
  # kernelName: The actual name of the kernel. For example, if in my source files I have __kernel void foo(), then "foo" is the kernel name.
  # call clUtilGrid() to generate an rvalue containing work size information
  # args: each argument corresponds to an argument the kernel accepts
  # ...

Return:
    None, but will print, trap, return if kernel does not exist, arguments don't match, or kernel fails to enqueue.

===clUtilEnqueueKernel() (with callback)===
{{{
void clUtilEnqueueKernel(const char* kernelName,
                         clUtilCallback&& callback,
                         clUtilGrid(globalDim1, localDim1, globalDim2, localDim2, ...)
                         Args... args)
}}}
Enqueues a kernel with function name kernelName on the current device and immediately returns. This function is variadic, so an arbitrary number of arguments can be specified as parameters to the kernel. This function does not call clFlush(), so the kernel may not actually start executing until the user calls clFlush(), clFinish(), a blocking copy, or an asychronous copy with shouldFlush equal to true. When the kernel finishes, the OpenCL runtime calls callback.

Parameters:
  # kernelName: The actual name of the kernel. For example, if in my source files I have __kernel void foo(), then "foo" is the kernel name.
  # callback: function called when kernel completes.
  # call clUtilGrid() to generate an rvalue containing work size information
  # args: each argument corresponds to an argument the kernel accepts
  # ...

Return:
    None, but will print, trap, return if kernel does not exist, arguments don't match, or kernel fails to enqueue.

==Images==
===clUtilCreateImage1D()===
{{{
cl_int clUtilCreateImage1D(size_t numPixels,
                           cl_channel_order order,
                           cl_channel_type type,
                           cl_mem* image)
}}}
Creates a 1D texture emulated on a 2D texture. numPixels is the number of elements in the texture, each of which is defined by order and type.

Parameters:
  # numPixels: The number of pixels in the image. The actual number of pixels allocated will be at least this number.
  # order: The channel order of each pixel. Table 5.5 of OpenCL spec lists valid options.
  # type: The type of each channel. Table 5.6 of OpenCL spec lists valid options.
  # image: A pointer to a handle that is assigned when texture is created.

Return:
    CL_SUCCESS if no error occurred. Otherwise, this function returns the internal error code.

===clUtilPutImage1D()===
{{{
cl_int clUtilPutImage1D(cl_mem image, const size_t offset, const size_t region, void* ptr)
}}}
Copies pixels between offset and offset+region from ptr (on host) to image (on device).

Parameters:
  # image: texture residing on current device.
  # offset: the number of pixels to skip over.
  # region: the number of pixels to copy to device.
  # ptr: address of first element of buffer containing image located on host.

Return:
    CL_SUCCESS if no error occurred. Otherwise, this function returns the internal error code.

===clUtilGetImage1D()===
{{{
cl_int clUtilGetImage1D(cl_mem image, const size_t offset, const size_t region, void* ptr)
}}}
Copies pixels between offset and offset+region from image (on device) to ptr (on host).

Parameters:
  # image: texture residing on current device.
  # offset: the number of pixels to skip over.
  # region: the number of pixels to copy to device.
  # ptr: address of first element of buffer containing image located on host.

Return:
    CL_SUCCESS if no error occurred. Otherwise, this function returns the internal error code.

===clUtilCopyToImageFloat()===
{{{
cl_int clUtilCopyToImageFloat(cl_mem buffer,
                              int offset,
                              int m,
                              int n,
                              int ld,
                              cl_mem* image)
}}}
Interpreting buffer starting at offset as a column-major single-precision matrix with m rows and n columns and a leading dimension of ld, allocate and copy this matrix into a 32-bit floating point alpha channel image. This image will have a width of m, a height of n, and one color per channel. This function is useful for accessing matrices through the texture cache. Upon return, "image" will point to the cl_mem handle containing the image. This function is an allocation, so you'll have to call clUtilFree() or clReleaseMemObject() to destroy it when you're finished with it.

Parameters:
  # buffer: a cl_mem handle to the buffer containing the source matrix
  # offset: the number of elements to skip before the matrix starts
  # m: the number of rows in the source matrix
  # n: the number of columns in the source matrix
  # ld: the leading dimension in the source matrix. Should be at least the number of columns.
  # image: upon return, this will point to the allocated image's handle
Return:
    CL_SUCCESS if no error occurred. Otherwise, this function returns the internal error code.

===clUtilCopyToImageTransposeFloat()===
{{{
cl_int clUtilCopyToImageTransposeFloat(cl_mem buffer,
                                       int offset,
                                       int m,
                                       int n,
                                       int ld,
                                       cl_mem* image)
}}}
Interpreting buffer starting at offset as a column-major single-precision matrix with m rows and n columns and a leading dimension of ld, allocate and transpose this matrix into a 32-bit floating point alpha channel image. This image will have a width of n, a height of m, and one color per channel. This function is useful for accessing matrices through the texture cache. Upon return, "image" will point to the cl_mem handle containing the image. This function is an allocation, so you'll have to call clUtilFree() or clReleaseMemObject() to destroy it when you're finished with it.

Parameters:
  # buffer: a cl_mem handle to the buffer containing the source matrix
  # offset: the number of elements to skip before the matrix starts
  # m: the number of rows in the source matrix
  # n: the number of columns in the source matrix
  # ld: the leading dimension in the source matrix. Should be at least the number of columns.
  # image: upon return, this will point to the allocated image's handle
Return:
    CL_SUCCESS if no error occurred. Otherwise, this function returns the internal error code.

===clUtilCopyToImageDouble()===
{{{
cl_int clUtilCopyToImageDouble(cl_mem buffer,
                               int offset,
                               int m,
                               int n,
                               int ld,
                               cl_mem* image)
}}}
Interpreting buffer starting at offset as a column-major double-precision matrix with m rows and n columns and a leading dimension of ld, allocate and copy this matrix into a 32-bit floating point red-green channel image. This image will have a width of n, a height of m, and two colors per channel. Use as_double() to reinterpret float2s as doubles. This function is useful for accessing matrices through the texture cache. Upon return, "image" will point to the cl_mem handle containing the image. This function is an allocation, so you'll have to call clUtilFree() or clReleaseMemObject() to destroy it when you're finished with it.

Parameters:
  # buffer: a cl_mem handle to the buffer containing the source matrix
  # offset: the number of elements to skip before the matrix starts
  # m: the number of rows in the source matrix
  # n: the number of columns in the source matrix
  # ld: the leading dimension in the source matrix. Should be at least the number of columns.
  # image: upon return, this will point to the allocated image's handle
Return:
    CL_SUCCESS if no error occurred. Otherwise, this function returns the internal error code.

===clUtilCopyToImageTransposeDouble()===
{{{
cl_int clUtilCopyToImageTransposeDouble(cl_mem buffer,
                                        int offset,
                                        int m,
                                        int n,
                                        int ld,
                                        cl_mem* image)
}}}
Interpreting buffer starting at offset as a column-major double-precision matrix with m rows and n columns and a leading dimension of ld, allocate and transpose this matrix into a 32-bit floating point red-green channel image. This image will have a width of m, a height of n, and two colors per channel. Use as_double() in kernels to reinterpret float2s as doubles. This function is useful for accessing matrices through the texture cache. Upon return, "image" will point to the cl_mem handle containing the image. This function is an allocation, so you'll have to call clUtilFree() or clReleaseMemObject() to destroy it when you're finished with it.

Parameters:
  # buffer: a cl_mem handle to the buffer containing the source matrix
  # offset: the number of elements to skip before the matrix starts
  # m: the number of rows in the source matrix
  # n: the number of columns in the source matrix
  # ld: the leading dimension in the source matrix. Should be at least the number of columns.
  # image: upon return, this will point to the allocated image's handle
Return:
    CL_SUCCESS if no error occurred. Otherwise, this function returns the internal error code.

===clUtilCopyToImageFloat4()===
{{{
cl_int clUtilCopyToImageFloat4(cl_mem buffer,
                               int offset,
                               int m,
                               int n,
                               int ld,
                               cl_mem* image)
}}}
Interpreting buffer starting at offset as a column-major single-precision matrix with m rows and n columns and a leading dimension of ld, allocate and copy this matrix into a 32-bit floating point red-green-blue-alpha channel image. This image will have a width of m/4 if 4 divides m and m/4 + 1 otherwise, a height of n, and four colors per channel. If m is not a multiple of 4, image will have padding (0.0f) in some of the channels in the last pixel. This function is useful for accessing matrices through the texture cache. Upon return, "image" will point to the cl_mem handle containing the image. This function is an allocation, so you'll have to call clUtilFfree() or clReleaseMemObject() to destroy it when you're finished with it.

Parameters:
  # buffer: a cl_mem handle to the buffer containing the source matrix
  # offset: the number of elements to skip before the matrix starts
  # m: the number of rows in the source matrix
  # n: the number of columns in the source matrix
  # ld: the leading dimension in the source matrix. Should be at least the number of columns.
  # image: upon return, this will point to the allocated image's handle
Return:
    CL_SUCCESS if no error occurred. Otherwise, this function returns the internal error code.

===clUtilCopyToImageTransposeFloat4()===
{{{
cl_int clUtilCopyToImageTransposeFloat4(cl_mem buffer,
                                        int offset,
                                        int m,
                                        int n,
                                        int ld,
                                        cl_mem* image)
}}}
Interpreting buffer starting at offset as a column-major single-precision matrix with m rows and n columns and a leading dimension of ld, allocate and copy this matrix into a 32-bit floating point red-green-blue-alpha channel image. This image will have a width of n/4 if 4 divides m and n/4 + 1 otherwise, a height of m, and four colors per channel. If n is not a multiple of 4, image will have padding (0.0f) in some of the channels in the last pixel. This function is useful for accessing matrices through the texture cache. Upon return, "image" will point to the cl_mem handle containing the image. This function is an allocation, so you'll have to call clUtilFree() or clReleaseMemObject() to destroy it when you're finished with it.

Parameters:
  # buffer: a cl_mem handle to the buffer containing the source matrix
  # offset: the number of elements to skip before the matrix starts
  # m: the number of rows in the source matrix
  # n: the number of columns in the source matrix
  # ld: the leading dimension in the source matrix. Should be at least the number of columns.
  # image: upon return, this will point to the allocated image's handle
Return:
    CL_SUCCESS if no error occurred. Otherwise, this function returns the internal error code.

===clUtilCopyToImageDouble2()===

===clUtilCopyToImageTransposeDouble2()===

==Debugging==

===clUtilDebugPrintImageFloat()===

===clUtilDebugPrintImageDouble()===

==Timing==
==clUtilGetTime()==
{{{
double clUtilGetTime()
}}}
Gets the "current time" in seconds with at least microsecond resolution. The difference between two calls of this function is the time elapsed between those two calls in seconds.

Parameters:
    None
Return:
    The current "time" in double precision.

----

=OpenCL Language Extensions=
clUtil adds several additional utility functions callable by kernels.

==1D Image Routines==
===read_1Dimage{f|i|ui}()===
{{{
float4 read_1Dimagef(image1d_t image,
                     samplet_t sampler,
                     int coord)

int4 read_1Dimagei(image1d_t image,
                   samplet_t sampler,
                   int coord)

uint4 read_1Dimageui(image1d_t image,
                     samplet_t sampler,
                     int coord)
}}}
These functions are the 1-D analogues of the image sampling functions found in 6.11.13.2 of OpenCL spec. Because the textures are emulated with 2-D textures, some sampling methods will result in undefined behavior:
  * Sampling beyond the bounds of the texture
  * Normalized coordinates

Parameters:
  # image: The image to sample.
  # sampler: The sampler to use.
  # coord: integer location to sample.
Return:
    These functions return the pixel located at coord.

===write_1Dimage{f|i|ui}()===
{{{
void write_1Dimagef(image1d_t image, int coord, float4 color)

void write_1Dimagei(image1d_t image, int coord, int4 color)

void write_1Dimageui(image1d_t image, int coord, uint4 color)
}}}
These functions are the 1-D analogues of the image writing functions found in 6.11.13.2 of the OpenCL spec. 

Parameters:
  # image: The image to sample.
  # coord: integer index of where to write in image
  # color: color to write to the index in texture.
Return:
    None.

==Algorithms==
===radixSort{LG | GL}()===
{{{
void radixSortLG(__global unsigned int* key,
                 __global unsigned int* val,
                 __global unsigned int* keyTmp,
                 __global unsigned int* valTmp,
                 unsigned int len,
                 __local unsigned int* zerosIndex,
                 __local unsigned int* onesIndex,
                 __local unsigned int* zerosScan,
                 __local unsigned int* onesScan)

void radixSortGL(__global unsigned int* key,
                 __global unsigned int* val,
                 __global unsigned int* keyTmp,
                 __global unsigned int* valTmp,
                 unsigned int len,
                 __local unsigned int* zerosIndex,
                 __local unsigned int* onesIndex,
                 __local unsigned int* zerosScan,
                 __local unsigned int* onesScan)
}}}

These functions cause the calling work group to sort the array of values in val using the keys in key. The threads in the 0th local work dimension work cooperatively to sort the array. The LG variant sorts from least to greatest while the GL version sorts greatest to least. The sorted values are placed in valTmp and the sorted keys are placed in keyTmp. The length of the arrays is given by len. The remaining four parameters are temporary storage used by radix sort and should be assumed modified after the function returns.

Sorts in 32*len/local_work_size(0) time.

*Note: Please make this function better. It's implementation is terrible and its interface is even worse.*

Parameters:
  # key - a pointer to the first key in the keys array. This array is also used as temporary storage by radixSort
  # val - a pointer to the first value in the values array. This array is also used as temporary storage by radixSort
  # keyTmp - a pointer to the first key in the output keys array. Upon completion, will have all the sorted keys.
  # valTmp - a pointer to the first value in the output values array. Upon completion, will contain the values sorted according to their corresponding key.
  # len - the length of the key, val, keyTmp, valTmp arrays.
  # zerosIndex - a pointer to local memory temporary storage. radixSort requires 1 unsigned int.
  # onesIndex - a pointer to local memory temporary storage. radixSort requires 1 unsigned int.
  # zerosScan - a pointer to local memory temporary storage. radixSort requires the length of this array equal the number of threads per work group in the 0th dimension.
  # onesScan - a pointer to local memory temporary storage. radixSort requires the length of this array equal the number of threads per work group in the 0th dimension.