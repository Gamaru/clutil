<wiki:toc max_depth="3" />

=Introduction=

If any of you have used OpenCL, you'll know that running a program in OpenCL is anything but easy. Consider the following example that fills an array with a specified value.
main.cc:
{{{
#include <Opencl/cl.h>

char const* kernelSource = "__kernel void fill(__global float* array, unsigned int arrayLength, float val)"
"{"
"    if(get_global_id(0) < arrayLength)"
"    {"
"        array[get_global_id(0)] = val;}"
"    }"
"}";

int main(int argc, char** argv)
{
    float val = 20.0f;
    float array[2000]
    cl_int err;
    cl_platform_id platform;
    cl_device_id device;
    cl_context context;
    cl_command_queue commandQueue;
    cl_mem buffer;
    cl_program program;
    cl_kernel kernel;
    unsigned int length = 2000;

    //Initialization
    err = clGetPlatform_IDs(1, &platform, NULL);
    err = clGetDeviceIDs(platform, CL_DEVICE_TYPE_ANY, 1, &device, NULL);
    context = clCreateContext(NULL, 1, &device, NULL, NULL, &err);
    commandQueue = clCreateCommandQueue(context, device, 0, &err);
    program = clCreateProgramWithSource(context, 1, &kernelSource, 0, &err);
    err = clBuildProgram(program, 1, &device, NULL, NULL, NULL);
    kernel = clCreateKernel(program, "fill", &err);

    //Allocate memory    
    buffer = clCreateBuffer(context, CL_MEM_READ_WRITE, sizeof(array), NULL, &err);

    //Actually call the kernel
    err = clSetKernelArg(kernel, 0, sizeof(buffer), &buffer);
    err = clSetKernelArg(kernel, 1, sizeof(length), &length);
    err = clSetKernelArg(kernel, 2, sizeof(val), &val);

    size_t global;
    size_t local = 64;
    
    global = length % local == 0 ? length : (length / local + 1) * local;

    err = clEnqueueNDRangeKernel(commandQueue, kernel, 1, NULL, &global, &local, 0, NULL, NULL);

    //Copy data back
    err = clEnqueueReadBuffer(commandQueue, buffer, CL_TRUE, 0, sizeof(array), array, 0, NULL, NULL);

    //Free the data on the GPU
    clReleaseMemObject(buffer);
}
}}}

This program doesn't even do error checking, which would at least double the program's length! clUtil dramatically improves frontend expressivity without significantly hurting flexibility. This means you write less code, spend less time debugging, and more time getting results.

The equivalent program in clUtil is as follows:

kernel.cl:
{{{
__kernel void fill(__global float* array, unsigned int arrayLength, float val)
{
    if(get_global_id(0) < arrayLength)
    {
        array[get_global_id(0)] = val;
    }
}
}}}
main.cc:
{{{
#include <clUtil.h>

int main(int argc, char** argv)
{
    const char* kernelFiles[] = {"kernel.cl"};
    cl_mem buffer;
    float array[2000];
    unsigned int length = 2000;
    float val = 20.0f;

    clUtil::initialize(kernelFiles, 1);
    clUtil::alloc(sizeof(array), &buffer);

    clUtil_enqueueKernel("fill", clUtilGrid(length, 64), buffer, length, val);
    clUtil::deviceGet(array, sizeof(array), buffer);

    clUtil::free(buffer);
}
}}}

=Design=

Simplifying the OpenCL API requires several assumptions and design decisions that trade expressivity for flexibility. This being said, clUtil still provides enough options for most applications. These assumptions include:
Simplified device/platform model
Simpler memory model
Stronger programming model
clUtil uses many features not available in C such as parameter defaulting and STL objects. Additionally, it uses variadic templates for launching kernels. Because of these language features, clUtil requires a C++ compiler with at least variadic template support of the C++0x standard. As such, one of the following compilers is required:
  * gcc 4.3 or later (use -std=c++0x flag on any file that includes clUtil.h). We have tested gcc 4.4.1 with x86_64-linux-gnu target.
We currently support Linux running OpenCL 1.0 or later. At present, we have tested clUtil using ATI's StreamSDK and Nvidia's CUDA. Unfortunately, there are known issues with both of these runtimes. As such, we have included mechanisms to allow users to design workarounds.

==Device Model==

clUtil makes no distinction between device platforms. Devices are devices and will implicitly run on the correct platform. On initialization, clUtil queries every platform available and combines all their device listings into a unified device list with the following assumptions (which will likely be loosened in the future):
  * No more than 64 platforms. Any platform beyond 64 are ignored.
  * No more than 64 devices. Any devices beyond 64 are ignored.
  * Each device has a single context.
  * Each device has a single command queue. It executes operations in order. We plan to support event-based execution in the future.
The device list is hidden from the user; they change the current device with a function call. Subsequent operations (memory allocations, kernels, etc.) will occur on the specified device. 
==Memory Model==

clUtil uses a simple memory model that behaves more like C. Buffers are allocated and freed instead of OpenCL's release/retain model. Since clUtil implements buffers using clCreateBuffer() and clReleaseMemObject(), a release/retain model can still be used, but is not the preferred way to do things. Data is synchronously (e.g. blocking is CL_TRUE) copied between device and host using devicePut() and deviceGet(). We plan to offer asynchronous data transfers in future releases. clUtil uses OpenCL's cl_mem objects, so many vanilla OpenCL functions should work on clUtil memory objects.

clUtil's memory model provides fewer options than vanilla OpenCL. All buffers are allocated on the currently selected device's only context. All buffers are read/write and do not use host pointer capabilities. We may add host pointer capabilities in future releases to accommodate performance improvements on devices that share host and device memory, such as AMD Fusion and Nvida mobile GPUs.

clUtil adds convenience functions for representing matrices as 2D images. Furthermore, clUtil adds support for 1D images by emulating them using 2D images. Additional functions exist in clUtil to create, copy to, and copy from 1-D images. They are visible to kernels as image1d_t types and are read and written to using [http://code.google.com/p/clutil/wiki/Documentation#1D_Image_Routines language extensions].

==Programming model==

clUtil makes dramatically simplifies OpenCL's programming model. Developers no longer have to worry about kernels, programs, binaries, etc. clUtil takes a list of source code files at initialization and compiles them all for each device on the machine. Calling a kernel is as simple as calling clUtil_enqueueKernel() after initialization with the kernel name, work dimension, global work size, local work size, and the arguments to the kernel. 

Since compiling source code can be take a while, developers can optionally pass a list of binary names to the initialization routine, causing clUtil to load kernels from these files if they exist. If they don't exist, clUtil will compile from source and save these binary files. This means that many applications can cache their programs after the first time the application is run.

==Thread safety==

clUtil is not currently thread safe. Switching devices occurs on a global level and calling different operations from different threads can cause race conditions on devices' queues. We plan to add thread safety by making the current device number a thread-local variable and adding mutex locking to command queues. For the time being, changing devices and issuing threads should occur only in critical sections.

=User Guide=

A typical OpenCL, CUDA, or clUtil application has a motif similar to the following:
  # Initialize
  # Allocate memory
  # Copy data to device
  # Run kernels
  # Copy data from device
  # Repeat 3-5
  # Shutdown

==Initialization==

With clUtil, step 1 is simplified to a single function call that initializes everything needed to run kernels and manipulate memory on any devices. The user does this by calling clUtil::initialize().

==Memory Management==

Once initialization is complete, the user can allocate and destroy buffers using clUtil::alloc() and clUtil::free() respectively. Users do not need to worry about kernels using buffers completing after free is called; OpenCL's runtime handles this. So long as the kernel is enqueued before free is called, the program should run correctly.

Data is copied from host to device using clUtil::devicePut(). Data is copied from device to host using clUtil::deviceGet(). Presently, all data transfers are blocking calls (e.g. they return when the transfer is complete). Device Management

All devices on all platforms are flattened into a single list behind the scenes. Users are abstracted away from this list and can change the current device using clUtil::setDeviceNum() and query the current device using clUtil::getDeviceNum(). The total number of devices across all platforms is accessible using clUtil::getNumDevices().

==Error handling==

Errors are signaled using return values as is done in C. When an error occurs, all clUtil functions do the following upon encountering an error on one of its internal OpenCL calls:
  # print the source file, line number on which the error occurred in clUtil, and what the error was.
  # raise a SIGTRAP
  # return the error code
This provides several different methods of debugging. Firstly, developers can lookup the file and line number in the clUtil library to see what function failed and try to find the offending calling code. Because of the SIGTRAP, the program will exit if SIGTRAP is not overloaded when run normally. However, if run in a debugger, the debugger will catch the SIGTRAP immediately pausing the program. This allows developers to get a stack trace with variable information and possibly continue execution.

Some functions may print additional information. For example, if clUtil::initialize() fails because a source file contained syntax errors, it will print the build log containing said errors, print "clUtil.cc:645::Failed to build program." to stdout, raise a SIGTRAP, and return CL_BUILD_PROGRAM_FAILURE.

The error handling macros used by clUtil that do the above are clUtilCheckErrorVoid() and clUtilCheckError(). The former should be used by functions that return void while the latter should be used by functions that return a value. Additionally, OpenCL error codes can be turned into plain English strings using clUtil::getErrorCode().

==Kernels==

To launch a kernel, call clUtil_enqueueKernel() with the name of the kernel, the work dimension, global size, local size, and arguments to the kernel. This function looks up the kernel by name in a hash table for the current device that is created when clUtil is initialized.

==Images==

clUtil's image functions are designed to be used with matrix data for linear algebra routines. They are intended to temporarily hold copies of matrices in images so they can run through the texture cache as inputs to a kernel. 

==Platform/Device Specific Compilation==

Presently, no implementation of OpenCL is perfect and each has various bugs and/or non-standard implementation details that need to have #define workarounds. Absent this, users may wish to include device-specific optimizations, such as using float4s on ATI hardware or unrolling loops to different lengths based on the underlying architecture. To facilitate this, clUtil defines macros for the current device vendor and (coming soon!) the current platform vendor. The macro defined is an uppercase version of the string returned by clGetDeviceInfo() with CL_DEVICE_VENDOR with spaces, commas, and periods replaced with underscores. 
NVIDIA CUDA SDK

  * Passing __constant address space pointers to kernels often causes compilation issues or doesn't work. Use __global instead.
AMD Stream SDK 2.3

  * Double precision is enabled via #pragma cl_amd_fp64 : enable instead of cl_khr_fp64 : enable.
  * Samplers can be inline declared in OpenCL programs using const sampler_t mySampler = CLK_NORMALIZED_COORDS_TRUE or __constant sampler_t mySampler = CLK_NORMALIZED_COORDS_TRUE. The former is non-standard and the only way to do it in v2.2. The latter is the standard way and is only supported in v2.3 and later.
  * As of v2.3, 1D images don't work (tested on Intel X5570) because 2D images don't work.

----

=Reference=

==Initialization==

===clUtilInitialize()===
{{{
cl_int clUtilInitialize(char** fileNames, 
                        size_t numFiles, 
                        const char* cacheName = NULL, 
                        const char* options = NULL)
}}}

This function initializes the clUtil runtime and must be the first clUtil function called. It initializes all devices on all platforms, creates a single context and command queue on each device, compiles all files given in fileNames into a single program on each device (or if possible load them from cached binaries), and set the current device to 0.

Parameters:
  # fileNames: an array of C-strings including filenames to be compiled into program on each device. Can have either relative or full paths to files.
  # numFiles: the number of files to be compiled
  # cacheName (optional): The name of the precompiled binary to be loaded as a program. Each device will have a file named (cacheName).device(deviceNumber). If the binaries don't exist, then they are compiled and saved to disk for future use.
  # options (optional): options passed to OpenCL compiler
Return:
    CL_SUCCESS if no error occurred. Otherwise, an error code corresponding to the erroneous underlying OpenCL call is returned after performing the previously described error handling.

==Memory Management==

===clUtilAlloc()===

{{{
clUtilAlloc(size_t bytes, cl_mem* gpuBuffer)
}}}

Allocates memory on the currently selected device.

Parameters:
  # bytes: number of bytes to be allocated
  # gpuBuffer: points to a cl_mem handle that is assigned if memory is successfully allocated.

Return:
    CL_SUCCESS if no error occurred. Otherwise, an error code corresponding to the erroneous underlying OpenCL call is returned after performing the previously described error handling.

===clUtilFree()===
{{{
clUtilFree(cl_mem buffer)
}}}
Frees a buffer after all previously enqueued kernels referencing it finish.

Parameters:

  # buffer: a cl_mem handle to the buffer to be freed

Return:
    CL_SUCCESS if no error occurred. Otherwise, an error code corresponding to the erroneous underlying OpenCL call is returned after performing the previously described error handling.

===clUtilDevicePut() (synchornous)===
{{{
cl_int clUtilDevicePut(void* buffer, size_t len, cl_mem gpuBuffer)
}}}
Copies data from the host buffer "buffer" to the device buffer "gpuBuffer" and returns when the copy is complete. Note: gpuBuffer must reside on the currently selected device or an error will occur. This function blocks until the copy completes.

Parameters:

  # buffer: a pointer to the zeroth element on the host's buffer
  # len: number of bytes of data to be copied
  # gpuBuffer: a cl_mem handle to the device buffer.
Return:
    CL_SUCCESS if no error occurred. Otherwise, an error code corresponding to the erroneous underlying OpenCL call is returned after performing the previously described error handling.

===clUtilDeviceGet() (synchronous)===
{{{
cl_int clUtilDeviceGet(void* buffer, size_t len, cl_mem gpuBuffer)
}}}
Copies data from the device buffer "gpuBuffer" to the host buffer "buffer" and returns when the copy is complete. Note: gpuBuffer must reside on the currently selected device or an error will occur. This function blocks until the copy completes.

Parameters:

  # buffer: a pointer to the zeroth element on the host's buffer
  # len: number of bytes of data to be copied
  # gpuBuffer: a cl_mem handle to the device buffer.
Return:
    CL_SUCCESS if no error occurred. Otherwise, an error code corresponding to the erroneous underlying OpenCL call is returned after performing the previously described error handling.

===clUtilDevicePut() (asynchornous)===
{{{
cl_int clUtilDevicePut(void* buffer, size_t len, cl_mem gpuBuffer, clUtilCallback&& callback, bool shouldFlush = true)
}}}
Asynchronously copies data from the host buffer "buffer" to the device buffer "gpuBuffer." Note: gpuBuffer must reside on the currently selected device or an error will occur. This function returns immediately.
When the copy complete's, the runtime calls "callback." Callbacks must be thread safe, as they are generally not called by the main thread.
If flush is true (the default), clFlush() is called on the current device's queue so the copy (and anything else in the queue) begin executing on the device. If flush is false, then clFlush() is not called and the copy may remain queued until the next flush is called. This permits optimization, as developers can have only the last concurrent asynchronous action issue the flush. This function should not block regardless of the value of flush, since clFlush() does not block (e.g. it is not clFinish).

Parameters:

  # buffer: a pointer to the zeroth element on the host's buffer
  # len: number of bytes of data to be copied
  # gpuBuffer: a cl_mem handle to the device buffer.
  # callback: the function called when the copy completes. Must have the interface void callback(void). Must be thread safe.
  # shouldFlush: if true, clUtilDevicePut() calls clFlush() after issuing the copy to the current devices command queue. If false, it only issues the copy into the command queue; it doesn't call clFlush(). This parameter defaults to true.

Return:
    CL_SUCCESS if no error occurred. Otherwise, an error code corresponding to the erroneous underlying OpenCL call is returned after performing the previously described error handling.

===clUtilDeviceGet() (asynchronous)===
{{{
cl_int clUtilDeviceGet(void* buffer, size_t len, cl_mem gpuBuffer, clUtilCallback&& callback, bool shouldFlush = true)
}}}
Asynchronously copies data from the device buffer "gpuBuffer" to the host buffer "buffer." Note: gpuBuffer must reside on the currently selected device or an error will occur. This function returns immediately.
When the copy complete's, the runtime calls "callback." Callbacks must be thread safe, as they are generally not called by the main thread.
If flush is true (the default), clFlush() is called on the current device's queue so the copy (and anything else in the queue) begin executing on the device. If flush is false, then clFlush() is not called and the copy may remain queued until the next flush is called. This permits optimization, as developers can have only the last concurrent asynchronous action issue the flush. This function should not block regardless of the value of flush, since clFlush() does not block (e.g. it is not clFinish).

Parameters:

  # buffer: a pointer to the zeroth element on the host's buffer
  # len: number of bytes of data to be copied
  # gpuBuffer: a cl_mem handle to the device buffer.
  # callback: the function called when the copy completes. Must have the interface void callback(void). Must be thread safe.
  # shouldFlush: if true, clUtilDevicePut() calls clFlush() after issuing the copy to the current devices command queue. If false, it only issues the copy into the command queue; it doesn't call clFlush(). This parameter defaults to true.

Return:
    CL_SUCCESS if no error occurred. Otherwise, an error code corresponding to the erroneous underlying OpenCL call is returned after performing the previously described error handling.

==Device Management==
===clUtilSetDeviceNum()===
{{{
cl_int clUtilSetDeviceNum(cl_int device)
}}}
Sets the current device to "device."

Parameters:

  # device: the cardinal number of the device to use. Devices can reside on any of the underlying platforms. Note that it's possible for the same device to appear several times if it's supported by multiple platforms. 
Return:
    CL_SUCCESS if no error occurred. CL_INVALID_VALUE if device is larger than the number returned by getNumDevices() or is negative.

===clUtilGetDeviceNum()===
{{{
cl_int clUtilGetDeviceNum()
}}}
Returns the cardinal number of the currently selected device or -1 if clUtil::initialize() has not been called.

Parameters:
    None
Return:
    The cardinal number of the currently selected device.

===clUtilGetNumDevices()===
{{{
cl_uint clUtilGetNumDevices()
}}}
Returns the sum of all devices on all platforms or 0 if either clUtil::initialize() has not been called or no device is supported by any OpenCL platform. Some devices may be enumerated more than once if they are supported by more than one platform.

Parameters:
    None
Return:
    The total number of devices on the system.

===clUtilGetDeviceName()===
{{{
char* clUtilGetDeviceName()
}}}
Returns a C-string containing the current device's name (e.g. GTX 480, Radeon 5870, etc.).

Parameters:
    None
Return:
    A C-string containing the currently selected device's name.

===clUtilGetDeviceVendor()===
{{{
char* clUtilGetDeviceVendor()
}}}
Returns a C-string containing the current device's vendor (e.g. Intel, Advance Micro Devices Inc., etc.).

Parameters:
    None
Return:
    A C-string containing the currently selected device's vendor.

===clUtilGetDeviceDriver()===
{{{
char* clUtilGetDeviceDriver()
}}}
Returns a C-string containing the current device's driver version number.

Parameters:
    None
Return:
    A C-string containing the currently selected device's driver version.

===clUtilGetMaxWriteImages()===
{{{
cl_uint clUtilGetMaxWriteImages()
}}}
Returns the maximum number of images any kernel can write to.

Parameters:
    None
Return:
    An unsigned integer containing the number of images a kernel running on the current device can write to.

===clUtilGetSupportedImageFormats()===
{{{
void clUtilGetSupportedImageFormats()
}}}
Prints all image formats supported by the currently selected device to stdout.

Parameters:
    None
Return:
    None

==Error handling==

===clUtilCheckErrorVoid(err)===
{{{
clUtilCheckErrorVoid(err) //[MACRO]
}}}
If err equals CL_SUCCESS, does nothing. Otherwise, it prints the file and line number of the call site as well as the plain text string of err. It then raises a trap signal and causes the calling function to immediately void return.

Parameters:
  # err: a cl_int representing an error code from an OpenCL or clUtil function call.
Return:
    Causes calling function to void return.

===clUtilCheckError(err, returnVal)===
{{{
clUtilCheckError(err, returnVal) //[MACRO]
}}}
If err equals CL_SUCCESS, does nothing. Otherwise, it prints the file and line number of the call site as well as the plain text string of err. It then raises a trap signal and causes the calling function to immediately return returnVal.

Parameters:
  # err: a cl_int representing an error code from an OpenCL or clUtil function call.
  # returnVal: the value the calling function should return.
Return:
    Causes the calling function to return returnVal.

===clUtilGetErrorCode()===
{{{
const char* clUtil::getErrorCode(cl_int err)
}}}
Returns a C-string containing the English text description of OpenCL error code err.

Parameters:
  # err: a cl_int representing an error code from an OpenCL or clUtil function call.
Return:
    A C-string containing a description of err.

==Kernels==
===clUtilGrid()===
{{{
clUtil::_Grid<> clUtilGrid(globalDim1, localDim1, globalDim2, localDim2, ...)
}}}
A variadic factory function that generates work information for clUtilEnqueueKernel(). Due to implementation details, this function should be used inline as a parameter to clUtilEnqueueKernel or assigned to an rvalue reference (e.g. clUtil::Grid&& gridRef = clUtilGrid(global1, local1, ...). This function rounds each global work size to the next largest multiple of the corresponding local size (unless the global work size is already a multiple of the local). Global and local work items must always come in pairs; failing to do so will result in a template instantiation error.

Parameters:
  # globalDim1: The total number of work items in the first dimension. See OpenCL spec on work items.
  # localDim1: The number of works items per work group in the first dimension.
  # ...

Return:
    A nasty subclassed templated thingy that should only be passed to clUtilEnqueueKernel.

===clUtilEnqueueKernel()===
{{{
void clUtilEnqueueKernel(const char* kernelName,
                         clUtilGrid(globalDim1, localDim1, globalDim2, localDim2, ...)
                         Args... args)
}}}
Enqueues a kernel with function name kernelName on the current device. This function is variadic, so an arbitrary number of arguments can be specified as parameters to the kernel.

Parameters:
  # kernelName: The actual name of the kernel. For example, if in my source files I have __kernel void foo(), then "foo" is the kernel name.
  # call clUtilGrid() to generate an rvalue containing work size information
  # args: each argument corresponds to an argument the kernel accepts
  # ...

Return:
    None, but will print, trap, return if kernel does not exist, arguments don't match, or kernel fails to enqueue.

==Images==
===clUtilCreateImage1D()===
{{{
cl_int clUtilCreateImage1D(size_t numPixels,
                           cl_channel_order order,
                           cl_channel_type type,
                           cl_mem* image)
}}}
Creates a 1D texture emulated on a 2D texture. numPixels is the number of elements in the texture, each of which is defined by order and type.

Parameters:
  # numPixels: The number of pixels in the image. The actual number of pixels allocated will be at least this number.
  # order: The channel order of each pixel. Table 5.5 of OpenCL spec lists valid options.
  # type: The type of each channel. Table 5.6 of OpenCL spec lists valid options.
  # image: A pointer to a handle that is assigned when texture is created.

Return:
    CL_SUCCESS if no error occurred. Otherwise, this function returns the internal error code.

===clUtilPutImage1D()===
{{{
cl_int clUtilPutImage1D(cl_mem image, const size_t offset, const size_t region, void* ptr)
}}}
Copies pixels between offset and offset+region from ptr (on host) to image (on device).

Parameters:
  # image: texture residing on current device.
  # offset: the number of pixels to skip over.
  # region: the number of pixels to copy to device.
  # ptr: address of first element of buffer containing image located on host.

Return:
    CL_SUCCESS if no error occurred. Otherwise, this function returns the internal error code.

===clUtilGetImage1D()===
{{{
cl_int clUtilGetImage1D(cl_mem image, const size_t offset, const size_t region, void* ptr)
}}}
Copies pixels between offset and offset+region from image (on device) to ptr (on host).

Parameters:
  # image: texture residing on current device.
  # offset: the number of pixels to skip over.
  # region: the number of pixels to copy to device.
  # ptr: address of first element of buffer containing image located on host.

Return:
    CL_SUCCESS if no error occurred. Otherwise, this function returns the internal error code.

===clUtilCopyToImageFloat()===
{{{
cl_int clUtilCopyToImageFloat(cl_mem buffer,
                              int offset,
                              int m,
                              int n,
                              int ld,
                              cl_mem* image)
}}}
Interpreting buffer starting at offset as a column-major single-precision matrix with m rows and n columns and a leading dimension of ld, allocate and copy this matrix into a 32-bit floating point alpha channel image. This image will have a width of m, a height of n, and one color per channel. This function is useful for accessing matrices through the texture cache. Upon return, "image" will point to the cl_mem handle containing the image. This function is an allocation, so you'll have to call clUtil::free() or clReleaseMemObject() to destroy it when you're finished with it.

Parameters:
  # buffer: a cl_mem handle to the buffer containing the source matrix
  # offset: the number of elements to skip before the matrix starts
  # m: the number of rows in the source matrix
  # n: the number of columns in the source matrix
  # ld: the leading dimension in the source matrix. Should be at least the number of columns.
  # image: upon return, this will point to the allocated image's handle
Return:
    CL_SUCCESS if no error occurred. Otherwise, this function returns the internal error code.

===clUtilCopyToImageTransposeFloat()===
{{{
cl_int clUtilCopyToImageTransposeFloat(cl_mem buffer,
                                       int offset,
                                       int m,
                                       int n,
                                       int ld,
                                       cl_mem* image)
}}}
Interpreting buffer starting at offset as a column-major single-precision matrix with m rows and n columns and a leading dimension of ld, allocate and transpose this matrix into a 32-bit floating point alpha channel image. This image will have a width of n, a height of m, and one color per channel. This function is useful for accessing matrices through the texture cache. Upon return, "image" will point to the cl_mem handle containing the image. This function is an allocation, so you'll have to call clUtil::free() or clReleaseMemObject() to destroy it when you're finished with it.

Parameters:
  # buffer: a cl_mem handle to the buffer containing the source matrix
  # offset: the number of elements to skip before the matrix starts
  # m: the number of rows in the source matrix
  # n: the number of columns in the source matrix
  # ld: the leading dimension in the source matrix. Should be at least the number of columns.
  # image: upon return, this will point to the allocated image's handle
Return:
    CL_SUCCESS if no error occurred. Otherwise, this function returns the internal error code.

===clUtilCopyToImageDouble()===
{{{
cl_int clUtilCopyToImageDouble(cl_mem buffer,
                               int offset,
                               int m,
                               int n,
                               int ld,
                               cl_mem* image)
}}}
Interpreting buffer starting at offset as a column-major double-precision matrix with m rows and n columns and a leading dimension of ld, allocate and copy this matrix into a 32-bit floating point red-green channel image. This image will have a width of n, a height of m, and two colors per channel. Use as_double() to reinterpret float2s as doubles. This function is useful for accessing matrices through the texture cache. Upon return, "image" will point to the cl_mem handle containing the image. This function is an allocation, so you'll have to call clUtil::free() or clReleaseMemObject() to destroy it when you're finished with it.

Parameters:
  # buffer: a cl_mem handle to the buffer containing the source matrix
  # offset: the number of elements to skip before the matrix starts
  # m: the number of rows in the source matrix
  # n: the number of columns in the source matrix
  # ld: the leading dimension in the source matrix. Should be at least the number of columns.
  # image: upon return, this will point to the allocated image's handle
Return:
    CL_SUCCESS if no error occurred. Otherwise, this function returns the internal error code.

===clUtilCopyToImageTransposeDouble()===
{{{
cl_int clUtilCopyToImageTransposeDouble(cl_mem buffer,
                                        int offset,
                                        int m,
                                        int n,
                                        int ld,
                                        cl_mem* image)
}}}
Interpreting buffer starting at offset as a column-major double-precision matrix with m rows and n columns and a leading dimension of ld, allocate and transpose this matrix into a 32-bit floating point red-green channel image. This image will have a width of m, a height of n, and two colors per channel. Use as_double() in kernels to reinterpret float2s as doubles. This function is useful for accessing matrices through the texture cache. Upon return, "image" will point to the cl_mem handle containing the image. This function is an allocation, so you'll have to call clUtil::free() or clReleaseMemObject() to destroy it when you're finished with it.

Parameters:
  # buffer: a cl_mem handle to the buffer containing the source matrix
  # offset: the number of elements to skip before the matrix starts
  # m: the number of rows in the source matrix
  # n: the number of columns in the source matrix
  # ld: the leading dimension in the source matrix. Should be at least the number of columns.
  # image: upon return, this will point to the allocated image's handle
Return:
    CL_SUCCESS if no error occurred. Otherwise, this function returns the internal error code.

===clUtilCopyToImageFloat4()===
{{{
cl_int clUtilCopyToImageFloat4(cl_mem buffer,
                               int offset,
                               int m,
                               int n,
                               int ld,
                               cl_mem* image)
}}}
Interpreting buffer starting at offset as a column-major single-precision matrix with m rows and n columns and a leading dimension of ld, allocate and copy this matrix into a 32-bit floating point red-green-blue-alpha channel image. This image will have a width of m/4 if 4 divides m and m/4 + 1 otherwise, a height of n, and four colors per channel. If m is not a multiple of 4, image will have padding (0.0f) in some of the channels in the last pixel. This function is useful for accessing matrices through the texture cache. Upon return, "image" will point to the cl_mem handle containing the image. This function is an allocation, so you'll have to call clUtil::free() or clReleaseMemObject() to destroy it when you're finished with it.

Parameters:
  # buffer: a cl_mem handle to the buffer containing the source matrix
  # offset: the number of elements to skip before the matrix starts
  # m: the number of rows in the source matrix
  # n: the number of columns in the source matrix
  # ld: the leading dimension in the source matrix. Should be at least the number of columns.
  # image: upon return, this will point to the allocated image's handle
Return:
    CL_SUCCESS if no error occurred. Otherwise, this function returns the internal error code.

===clUtilCopyToImageTransposeFloat4()===
{{{
cl_int clUtilCopyToImageTransposeFloat4(cl_mem buffer,
                                        int offset,
                                        int m,
                                        int n,
                                        int ld,
                                        cl_mem* image)
}}}
Interpreting buffer starting at offset as a column-major single-precision matrix with m rows and n columns and a leading dimension of ld, allocate and copy this matrix into a 32-bit floating point red-green-blue-alpha channel image. This image will have a width of n/4 if 4 divides m and n/4 + 1 otherwise, a height of m, and four colors per channel. If n is not a multiple of 4, image will have padding (0.0f) in some of the channels in the last pixel. This function is useful for accessing matrices through the texture cache. Upon return, "image" will point to the cl_mem handle containing the image. This function is an allocation, so you'll have to call clUtil::free() or clReleaseMemObject() to destroy it when you're finished with it.

Parameters:
  # buffer: a cl_mem handle to the buffer containing the source matrix
  # offset: the number of elements to skip before the matrix starts
  # m: the number of rows in the source matrix
  # n: the number of columns in the source matrix
  # ld: the leading dimension in the source matrix. Should be at least the number of columns.
  # image: upon return, this will point to the allocated image's handle
Return:
    CL_SUCCESS if no error occurred. Otherwise, this function returns the internal error code.

===clUtilCopyToImageDouble2()===

===clUtilCopyToImageTransposeDouble2()===

==Debugging==

===clUtilDebugPrintImageFloat()===

===clUtilDebugPrintImageDouble()===

==Timing==
==clUtilGetTime()==
{{{
double clUtilGetTime()
}}}
Gets the "current time" in seconds with at least microsecond resolution. The difference between two calls of this function is the time elapsed between those two calls in seconds.

Parameters:
    None
Return:
    The current "time" in double precision.

=OpenCL Language Extensions=
clUtil adds several additional utility functions callable by kernels.
==1D Image Routines==
===read_1Dimage{f|i|ui}()===
{{{
float4 read_1Dimagef(image1d_t image,
                     samplet_t sampler,
                     int coord)

int4 read_1Dimagei(image1d_t image,
                   samplet_t sampler,
                   int coord)

uint4 read_1Dimageui(image1d_t image,
                     samplet_t sampler,
                     int coord)
}}}
These functions are the 1-D analogues of the image sampling functions found in 6.11.13.2 of OpenCL spec. Because the textures are emulated with 2-D textures, some sampling methods will result in undefined behavior:
  * Sampling beyond the bounds of the texture
  * Normalized coordinates

Parameters:
  # image: The image to sample.
  # sampler: The sampler to use.
  # coord: integer location to sample.
Return:
    These functions return the pixel located at coord.

===write_1Dimage{f|i|ui}()===
{{{
void write_1Dimagef(image1d_t image, int coord, float4 color)

void write_1Dimagei(image1d_t image, int coord, int4 color)

void write_1Dimageui(image1d_t image, int coord, uint4 color)
}}}
These functions are the 1-D analogues of the image writing functions found in 6.11.13.2 of the OpenCL spec. 

Parameters:
  # image: The image to sample.
  # coord: integer index of where to write in image
  # color: color to write to the index in texture.
Return:
    None.